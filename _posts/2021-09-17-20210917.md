---
title: "2021년 09월 17일 TIL"
date: 2021-09-17 00:23:00 -0400
categories: TIL
---


백신 주사를 맞고와서 CS 공부에 열중한 하루였다.

## HTTPS/SSL 기본 원리

### : 대칭키 방식과 공개키 방식을 혼용하여 서버의 신원을 보증하고, 데이터 통신을 암호화 한다.

1. 내 서버에서 '비밀키/공개키'를 생성한다.
2. 공인기관(CA)에서 내 서버의 SSL인증서를 발급 받는다.
   - SSL인증서는 'CA의 비밀키'로 암호화 되어 있으며,
   - 인증서 내부에는 '내 서버의 공개키'가 저장되어 있다.
3. 내 서버에 인증서를 저장하고, SSL 통신을 설정해둔다.
4. 브라우저가 내 서버에 접속하면 인증서를 보내준다.
5. 브라우저는 받은 인증서를 'CA의 공개키'로 복호화한다.
   - 인증서는 '발급한 CA의 비밀키'로 암호화 되어 있으며,
   - 브라우저(크롬, 사파리 등)은 '공인된 CA들의 공개키'를 내부에 보관하고 있다.
6. 인증서 복호화에 성공한다면, 해당 인증서가 CA가 발급한 것임이 증명된다.
   - 인증서를 보낸 '내 서버'도 CA가 인증한 서버임이 증명된다.
7. 복호화한 인증서에서 '내 서버의 공개키'를 취득하여 데이터 통신에 활용한다.
   - 서버와 주고 받는 데이터 자체는 '대칭키 방식'으로 암호화 하고,
   - '대칭키 방식에 사용된 key'를 '내 서버의 공개키'로 암호화 한다.



SSL=TLS

네스케이프에 의해서 발명되었고 사용하는 이가 많아지다가 표준화 기구인 IETF의 관리하에 TLS라는 이름을 가지게 되었다.

정식명칭은 TLS이지만, 역사적이유로 많이 쓰이는 명칭이 SSL인 샘이다.



### SSL 동작 순서

**SSL은 3가지 동작을 한다. "악수 -> 전송 -> 세션종료"**

 

 **1. Handshake( 악수 )**

 \- SSL 인증서를 주고 받는다.

 \- 공개키 방식으로 대칭키 값을 암호화 해서 전송한다.

> 클라이언트가 서버에 접속한다. 이 단계를 Client hello라고 한다.

i. 클라이언트 측에서 생성한 랜덤 데이터: 대칭키 값을 생성하는데 사용된다.

ii. 클라이언트가 지원하는 암호화 방식들: 클라이언트와 서버가 지원하는 암호화 방식이 서로 다를 수 있기 때문에, 

상호간에 어떤 암호화 방식을 사용할 것인지에 대한 협상을 한다. 

이 협상을 위해서 클라이언트 측에서 자신이 사용할 수 있는 암호화 방식들을 전송한다.

iii. 세션 아이디: 이미 SSL 핸드쉐이킹을 했다마면 비용과 시간을 절약하기 위해서 기존의 세션을 재활용 하게 되는데,

이 때 사용할 연결에 대한 식별자를 서버측으로 전송한다.

 

> 서버는 Client hello에 대한 응답으로 Server hello를 하게 된다.

i. 서버 측에서 생성한 랜덤 데이터: 대칭키 값을 생성하는데 사용된다.

ii. 서버가 선택한 클라이언트의 암호화 방식: 클라이언트가 전달한 암호화 방식 중에서 서버 쪽에서도 사용할 수 있는

암호화 방식을 선택해서 클라이언트로 전달한다.

iii. SSL 인증서

 

> 대칭키 값(= session key )은 어떻게 만들어 지는가?

클라이언트는 전달받은 서버의 랜덤 데이터와 본인이 생성한 랜덤 데이터를 조합해서 pre master secret를 생성한다.

생성한 pre master secret는 공개키 방식으로 암호화 해서 서버로 전송한다.

서버와 클라이언트는 모두 일련의 과정을 거쳐 pre master secret 값을 master secret 값으로 만든다.

Master secret는 session key를 생성하는데, 이 session key 값을 이용해 서버와 클라이언트는 데이터를 대칭키 방식으로 암호화 한다.

 

 **2. Session( 세션 )**

 \- 실제로 서버와 클라이언트가 데이터를 주고 받는 단계

 \- 정보를 상대방에게 전송하기 전에 session key 값을 이용해서 대칭키 방식으로 암호화 한다.

 

 **3. Session end( 세션 종료 )**

 \- 데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려준다.

 \- 통신에 사용한 대칭키인 세션키를 폐기한다.

 

▷ **다시 한번 짚고 가기!**

그냥 공개키를 사용하면 될 것을 대칭키와 공개키를 조합해서 사용하는 이유는 무엇을까? 그것은 공개키 방식이 많은 컴퓨터 파워를 사용하기 때문이다. 만약 공개키를 그대로 사용하면 많은 접속이 몰리는 서버는 매우 큰 비용을 지불해야 할 것이다. 

반대로 대칭키는 암호를 푸는 열쇠인 대칭키를 상대에게 전송해야 하는데, 암호화가 되지 않은 인터넷을 통해서 키를 전송하는 것은 위험하기 때문이다. 그래서 속도는 느리지만 데이터를 안전하게 주고 받을 수 있는 공개키 방식으로 대칭키를 암호화하고, 

실제 데이터를 주고 받을 때는 대칭키를 이용해서 데이터를 주고 받는 것이다.



## Hash vs Encryption(암호화)

이 둘은 혼동하기 쉽지만, 차이가 있다.

### Hash 

해시는 가변 길이의 데이터를 해시 함수를 이용해 고정 길이의 해시값으로 만들어내는 방법이다.

해시 값이 다르면 그 해시 값을 만들기 위해 사용한 원래의 데이터도 달라야한다.

비밀번호: 보통 유저의 비밀번호를 암호화해서 저장한다고 한다. 그러나 암호화의 경우는 복호화를 통해 실제 비밀번호를 알아낼 수 있으므로 암호화가 아닌 해시 함수를 이용해 생성된 해시 값을 저장해야한다.

- MD5

  - **`MD5(Message-Digest algorithm 5)`는 128비트의 해시 값을 생성하는 해시 함수이다.** 주로 프로그램이나 파일이 원본 그대로인지를 확인하는 무결성 검사 등에 사용된다. 이전에 쓰이던 MD4를 대체하기 위해 만들어졌다.
    - 현재는 결함으로 쓰이지 않음.

- SHA 256

  - **`SHA-256`은 SHA(Secure Hash Algorithm) 알고리즘의 한 종류로서 256비트의 해시 값을 생성하는 해시 함수이다.** SHA-256은 미국의 국립표준기술연구소(NIST; National Institute of Standards and Technology)에 의해 공표된 표준 해시 알고리즘인 SHA-2 계열 중 하나이며 블록체인에서 가장 많이 채택하여 사용하고 있다.

    개인용 컴퓨터로 무차별 대입을 수행해 해시 충돌 사례를 찾으려고 할 때 많은 시간이 소요될 정도로 큰 숫자이므로 충돌로부터 비교적 안전하다고 평가된다.

    아래 코드에서는 SHA-256 해시 함수를 통해 해시 값(256비트)을 생성하고 Hex string으로 변환하였다.

### Encryption

암호화는 복호화(Decryption)을 할 수 있는 Key를 소유한 사람을 제외하고 원래의 데이터를 읽어볼 수 없도록 암호화 알고리즘을 이용해 데이터를 전달하는 것.

즉 암호화를 통해 생성된 값은 복호화를 통해 원래의 데이터를 알 수 있지만, 해시를 통해 만들어진 고정된 길이의 해시 값은 원래의 데이터를 알 수 없다.
