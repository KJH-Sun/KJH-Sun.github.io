---
title: "2021년 09월 15일 TIL"
date: 2021-09-15 00:23:00 -0400
categories: TIL
---


오늘의 공부 내용 

## 트랜잭션

**Atomicity(원자성)**

**1.** 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다.

**2.** 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.

**Consistency(일관성)**

**1.** 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.

**2.** 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 한다.

**Isolation(독립성,격리성)**

**1.** 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없다.

**2.** 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.

**Durablility(영속성,지속성)**

**1.** 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.



### WAL(Write-ahead logging), 로그 선행 기입

데이터베이스 시스템에서 ACID(원자성, 일관성, 고립성, 지속성)의 특성 가운데에 원자성과 내구성을 제공하는 기술의 한 계열이다.

WAL을 사용하는 시스템에서 모든 수정은 적용 이전에 로그에 기록된다. 일반적으로 redo 및 undo 정보는 둘 모두 로그에 저장된다.

WAL은 데이터베이스 업데이트가 인플레이스 알고리즘(in-place algorithm, 제자리 알고리즘)을 사용할 수 있게한다. 다른 방식으로는, 그림자 페이징 기법을 사용하는 방법이 있다. inplace 알고리즘 사용 시에는 색인과 블록 목록의 수정 필요성을 줄일 수 있다.

### 데이터 베이스 회복 기법

- 로그 기반 회복 기법

  - 지연 갱신 회복 기법

    - 변경 내용을 로그에만 저장하다가 Commit이 발생하면 로그를 이용해 저장하는 기법
    - 회복 시 UNDO 필요 없이 REDO만 실행
    - 시스템 붕괴시 로그에 있는 정보는 버림

  - 즉시 갱신 회복 기법

    - 트랜잭션 수행 도중 데이터 변경 시 변경 정보 로그에 저장, 트랜잭션이 부분 완료되기 전이라도 모든 변경 내용을 즉시 DB에 반영
    - 회복 시 로그 파일 참조하여 REDO와 UNDO를 모두 실행
    - 로그 파일을 참조해 미완료된 변경에 UNDO를 우선 실행 후, 완료된 변경에 REDO를 실행

  - 체크포인트 회복 기법

    - 검사점 이후 , 장애 발생 이전에 Commit 된 경우 UNDO
    - 검사점 이후, 장애 발생 시점까지 Commit이 없는 경우 REDO

  - 미디어 회복 기법

    - 디스크 같은 비휘발성 저장 장치가 손상되는 장애 발생을 대비한 회복 기법

    - DB 내용을 백업, 미러링, RAID(여러 개의 디스크를 묶어 하나의 디스크처럼 사용하는 기술, Redundant Array of Independent Disk - 독립 디스크의 복수 배열)

    - 미디어 장애시 가장 최근 덤프로 복구하고 로그 파일을 참조해 덤프 이후의 작업을 Redo

      - RAID Level

        - RAID 0~6 까지 있으며, RAID를 구성하는 디스크의 종류와 크기는 같다고 가정

        - RAID 0 

          - Striping(스트라이핑)
          - RAID 0를 구성하기 위해서 최소 2개의 디스크 필요
          - RAID를 구성하는 모든 디스크에 데이터를 분할하여 저장
          - 전체 디스크를 사용하기에 성능은 단일 디스크의 성능의 N배, 용량 역시 단일 디스크의 N배
          - 그러나 하나의 디스크라도 문제 발생 시 전체 RAID가 깨지므로, 안정성은 1/N(실제 서버에선 거의 사용 X)

        - RAID 1

          - Mirroring(미러링)
          - RAID 1을 구성하기 위해 최소 2개의 디스크 필요
          - 모든 디스크에 데이터를 복제하여 기록하며, 그래서 실제 사용 가능한 용량과 Write 성능은 오히려 단일 디스크보다 떨어질 수 있다. 그러나 Read 성능은 N개의 디스크에서 동시에 읽기에 오히려 높게 나올 수도 있다.

        - RAID 2

          - 현재는 사용되지 않는 RAID Level
          - bit 단위로 Striping, error correction을 위해 Hamming code 사용
          - 최소 3개의 디스크로 구현 가능 (m+1개의 데이터 디스크, M개의 패리티 디스크)

        - RAID 3, 4

          - RAID 0, 1을 보완하기 위한 방식

          - #### RAID 3, 4는 기본적으로 RAID 0과 같은 striping 구성을 하고 있어 

            #### 성능을 보안하고 디스크 용량을 온전히 사용할 수 있게 해주는데 여기에 추가로 에러 체크 및 수정을 

            #### 위해서 패리티 정보를 별도의 디스크에 따로 저장하게 됩니다.

            #### RAID 3은 데이터를 바이트 단위로 나누어 디스크에 동등하게 분산 기록하며 RAID 4는 데이터를 

            #### 블록 단위로 나눠 기록하므로 완벽하게 동일하진 않다는 차이가 있습니다. 

            #### RAID 3은 드라이브 동기화가 필수적이라 많이 사용되지 않고 RAID 4를 더 많이 쓴다고 보시면 됩니다.

            

  - 그림자 페이징 회복 기법

    - 트랜잭션이 실행되는 메모리상의 Current Page Table과 하드디스크의 Shadow Page Table 이용
    - 트랜잭션 시작 시점에 Current page Table과 동일한 Shadow Page Table 생성
    - 트랜잭션 완료 시점에 Shadow 삭제
    - 실패 시 Shadow를 Current로 변경

  - ARIES 회복 기법

    - REDO 중 Repeating history : 붕괴가 발생했을 때의 DB 상태를 복구하기 위해서 붕괴 발생 이전의 모든 연산을 다시 한번 수행, 붕괴가 발생했을 때 완료되지 않은 상태였던(진행하던 트랜잭션)은 UNDO
    - UNDO 중 Logging : UNDO를 할 때에도 로깅을 함으로써 회복을 수행하는 도중에 실패하여 회복을 다시 시작할 때에 이미 완료된 UNDO 연산을 반복하지 않음.


### IP Class 개념

- IP Class의 경우 A, B, C, D, E Class로 나누어 Network ID와 Host ID를 구분하게 된다.

> A Class

- 처음 8bit(1byte)가 Network ID이며, 나머지 24bit(3byte)가 Host ID로 사용된다.
- 비트가 0으로 시작하기에 네트워크 할당은 0~127이다.
- 즉 128곳에 가능하며 최대 호스트 수는 16,777,214개이다.

> B Class

- 처음 16bit(2byte)가 Network ID이며, 나머지 16bit(2byte)가 Host ID로 사용된다.
- 비트가 10으로 시작하기에 네트워크 할당은 16,384곳에 가능하며 최대 호스트 수는 65,534개이다.

> C Class

- 처음 24bit(3byte)가 Network ID이며, 나머지 8bit(1byte)가 Host ID로 사용된다.
- 비트가 110으로 시작하기에 네트워크 할당은 2,097,152 곳에 가능하며, 최대 호스트 수는 254개이다.

> D Class와 E Class

- 실제 Network에서 사용되는 Class는 A, B, C Class이며, D Class는 Multicast(멀티캐스트), E Class는 미래에 사용하기 위해 남겨둔 것으로 예약되어 있다.
- 실질적으로 D와 E Class의 경우 사용되는 경우는 거의 없다.

- 사설 IP

  - 공인 IP 주소가 공개형이라면 사설(private) IP 주소는 폐쇄형이다.
  - 공인되지 않은 IP 주소라는 의미 때문이다.
  - 즉, 이 사설 IP 주소는 외부에 공개되지 않아 외부에서 검색, 접근이 근본적으로 불가능하다.
  - **사설 IP 주소**는 **주소 대역**이 **3개**로 고정되어 있다.
  - 이를테면, **192.168.xxx.xxx**와 **172.10.xxx.xxx**, 그리고 **10.xxx.xxx.xxx** 대역이다.
  - 이러한 사설 IP 주소는 인터넷 유무선 공유기를 사용할 때 흔히 접하게 되는데,
    **하나의 공인 IP 주소**를 **공유**하여 여러 대의 컴퓨터가 인터넷에 접속하게 하려면 사설 IP 주소가 필요하기 때문이다.
  - 예를 들어, 그 동안 컴퓨터 한 대를 100.100.100.100라는 공인 IP 주소로 설정해 인터넷에 접속하다가
    유무선 인터넷 공유기를 설치해 연결했다면, 이후로는 공유기 IP 주소가 100.100.100.100이 되고
    공유기에 연결된 해당 컴퓨터에는 192.168.0.10 등과 같은 사설 IP 주소가 할당된다.
  - 이러한 사설 IP 주소를 **사용**하는 **이유**는 **두 가지**다.
  - 하나는 위에서 언급한 대로 **IP 주소**를 **공유**하기 위함이다.
  - 이는 IPv4 체계의 **IP 주소 부족 문제**를 해결할 수 있는 방안이기도 하다.

- Link local address(링크 로컬 주소)

  - 브로드 캐스트 도메인 내의 통신에 대해서만 유효한 네트워크 주소
  - 169.254.1.0 ~ 169.254.254.255의 범위로 예약되어 있는 네트워크 주소
  - 사용 이유
    - 장치가 DHCP 서버를 찾지 못하여 IP를 할당받지 못하거나, static IP로의 설정 또한 지정되어 있지 않을 경우, 자동적으로 자신의 IP를 할당하기 위해서 사용함.
      - DHCP(Dynamic Host Configuration Protocol)
        - 호스트의 IP 주소와 각종 TCP/IP 프로토콜의 기본 설정을 클라이언트에게 자동적으로 제공해주는 프로토콜을 말한다.
    - 추후 장치에 대한 검색, IP 변경을 원격으로 진행할 수 있도록 링크 로컬 주소가 사용됨

- 6to4 릴레이 애니캐스트

  - IPv6 주소를 IPv4네트워크에 연결하기 위한 주소?

  유니캐스트 / 멀티 캐스트 / 브로드 캐스트

  - 유니캐스트
    - 1:1 통신, 현재 네트워크에서 가장 많이 사용되는 방식
    - **유니캐스트 통신 방식은 Destination을 제외한 다른 네트워크상의 PC들의 CPU 성능을 저하시키지 않는다.**
    - 자신의 MAC Address가 아니라고 판단되면 **랜카드에서 해당 Frame을 버리기 때문**이다. 하지만 그룹 통신을 위해 다중 수신자들에게 동일한 데이터를 전송하고자 할 경우 유니 캐스트 전송방식을 이용한다면, 전송하고자 하는 데이터 패킷을 다수의 수신자에게 여러번 전송해야 하며, 동일한 패킷의 중복 전송으로 인해 네트워크 효율이 저하된다.
  - 브로드캐스트
    - 자신의 호스트가 속한 네트워크 전체를 대상으로 패킷을 전송하는 일대다 통신방식
    - 브로드캐스트는 **Local LAN 상에 붙어있는 모든 네트워크 장비들**에게 보내는 통신이다. 여기서 **Local이란 라우터에 의해서 구분되어진 공간**, 즉 브로드캐스트 도메인 이라고 하는 공간을 뜻한다. 브로드캐스트 주소는 미리 정해져 있는데, 이 주소가 오면 랜카드는 비록 자신의 MAC Address와 같지는 않지만 해당 브로드캐스트 패킷을 CPU에 전달하게 된다.(수신을 거부할 수 없음)
    - 브로드캐스트는 반드시 필요한 통신방식이지만, 데이터를 수신할 필요가 없는 호스트 들에게도 데이터가 전송되기 때문에 불필요한 인터럽트가 발생되며, **브로드캐스트는 자신이 속한 네트워크에만 한정되고, 라우터를 경유하지 못하는 단점**이 있다.
  - 멀티캐스트
    - 특정한 하나 이상의 수신자들에게 데이터를 전송하는 방식
    - 멀티캐스트의 경우 자신이 데이터를 받기 원하는 특정 호스트 들에게만 보내는 것이 가능하지만, **스위치나 라우터가 이 기능(MultiCast Forwarding)을** 지원해 주어야 한다.
    - 멀티캐스트 전송을 위한 그룹 주소는 D Class IP 주소(224.0.0.0 ~ 239.255.255.255)로 전세계 개개인의 인터넷 호스트를 A, B, C Class IP 주소와는 달리 실제의 호스트를 나타내는 주소가 아니며, 그룹 주소를 갖는 멀티캐스트 패킷을 전송받는 수신자는 자신이 패킷의 그룹에 속해있는 가를 판단해 패킷의 수용여부를 결정하게 된다.
    - 현재 인터넷상의 라우터들은 대부분 유니캐스트만을 지원하기 때문에 멀티캐스트 패킷을 전송하기 위해서는 멀티캐스트 **라우터 사이에 터널링(tunneling)이라는 개념을 사용**하여 캡슐화(Encapsulation)된 패킷을 전송 한다. 즉 멀티캐스트 주소를 가진 데이터 패킷 헤더 앞에 멀티캐스트를 지원하지 않는 일반 라우터들을 거칠 경우, 기존의 유니캐스트 패킷과 같은 방법으로 라우팅 되어 최종적으로 터널의 종착지(Node)로 전송될 수 있게 하는 것이다.


IP주소와 서브넷 마스크를 통해 네트워크 주소 / 브로드캐스트 주소 계산하는 법
1. IP 주소와 서브넷 마스크를 & 연산한다 -> 네트워크 주소
2. 서브넷 마스크의 0비트가 있던 자리를 네트워크 주소에서 1로 바꾼다. -> 브로드캐스트 주소
3. 네트워크 주소와 브로드캐스트 주소를 제외한 주소들은 게이트웨이로 동작할 수 있다.




